# 方法和递归

[toc]



## 方法

```java
System.out.println("hello world!");
```

Java方法是语句的集合，它们组合在一起完成一个功能：

- 方法是解决一个问题的步骤的有序组合
- 方法包含于类或对象中



### 方法的定义

一般情况下，定义一个方法包含以下语法：

```txt
修饰符 返回值类型 方法名(参数表) 异常表 {
    ...
    方法体
    ...
    return 返回值;
}
```

- **修饰符：**修饰符是可选的，修饰符包括public、private、static等等。
- **返回值类型 ：**返回值类型是必需的，如果方法有返回值，方法返回值类型标识了返回值的数据类型。如果方法没有返回值，返回值类型是关键字**void**。
- **方法名：**方法名是必需的，是方法的名称。方法的建议命名规则(驼峰命名法)：方法的名字的第一个单词应以小写字母作为开头，后面的单词则用大写字母开头写，不使用连接符。例如：`addPerson`。
- **参数表：**参数表是可选的。参数像是一个占位符，有参数数据类型和参数名组成。方法可以有多个参数，由逗号`,`分隔，方法也可以不包含任何参数。当方法被调用时，需要传递值给参数。
- **异常表：**异常表是可选的。指明该方法可能会出现的异常情况。
- **方法体：**方法体是必需的。方法体包含具体的语句，定义该方法的功能。

例如，定义如下方法，将输出10个`*`号：

```java
void printTenStars(){
    System.out.println("**********");
}
```

练习：给上述方法增加一个参数，可以根据参数输出指定数量的`*`号。

方法签名：方法名和参数表共同构成方法签名。例如：

```java
public double calculateAnswer(double wingSpan, int numberOfEngines, double length, double grossTons) {
    //do the calculation here
}
```

上述方法签名为：

```java
calculateAnswer(double, int, double, double)
```



### 方法调用

我们可以使用如下语法调用已定义的方法：

```java
[方法返回值类型 变量名 = ] 方法名(实际参数列表);
```

例如，调用` printTenStars`方法语句如下：

```java
printTenStars();
```

如果方法返回值类型不为`void`，则可以接收返回值：

```java
public int calculateArea(int width, int height){
    return width * height;
}

int area = calculateArea(10, 5);
```

如果方法声明中包含参数，那么我们在调用方法时，就要进行参数传递，如上所示。

在程序设计语言中，参数有形式参数和实际参数之分，先来看下它们的定义：

> 形式参数：是在定义方法的时候使用的参数，目的是用来接收调用该函数时传入的参数，简称“形参”。
>
> 实际参数：在调用方法时，方法名后面括号中的参数称为“实际参数”，简称“实参”。

在Java中，参数传递的机制有两种—值传递和引用传递：

> 值传递：是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。对于基本数据类型，采用值传递的方式。
>
> 引用传递：是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。对于引用数据类型，采用引用传递的方式。

在我看来，值传递和引用传递都是一样的，可以统一理解为将实参复制一份给形参。

函数调用的方式与Java程序内存分配：

![image-20220805113356381](img/06.%E6%96%B9%E6%B3%95%E5%92%8C%E9%80%92%E5%BD%92/image-20220805113356381.png)

练习：

1. 请编写一个方法，用于计算整型数组的总和。
2. 请编写一个方法，用于交换两个整型变量的值。
3. 请编写一个方法，用于数组排序。



### 方法重载

重载(overloading) 是指多个方法，每个方法的名字相同，参数不同。返回类型可以相同也可以不同。

每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。

**重载规则:**

- 被重载的方法必须改变参数列表(参数个数或类型或顺序不一样)；
- 被重载的方法可以改变返回类型；
- 被重载的方法可以改变访问修饰符；
- 被重载的方法可以声明新的或更广的检查异常；
- 无法以返回值类型作为重载函数的区分标准；
- 方法能够在同一个类中或者在一个子类中被重载；

例如：

```java
public static int sum(int a, int b){
    return a + b;
}

public static double sum(double a, double b){
    return a + b;
}
```



## 递归

> 如果你不理解递归，请将这句话再阅读一遍。

所谓递归，就是在方法体中调用自己。例如：

```java
void recurse(){
    recurse();
}
```

上面就是一个简单的递归，但是，这种递归不会结束，会造成程序的“死循环”。为了结束递归，我们需要使用一些条件。例如：

```java
void recurse(int n){
    if(n <= 100)
        return;
    n--;
    recurse(n);
}

recurse(1000);
```

练习：

1. 请使用递归解决阶乘问题。例如，给你一个数n，求出`n!`的值。

2. 汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。

   后来，这个传说就演变为汉诺塔游戏，玩法如下:

   - 有三根杆子A,B,C。A杆上有若干碟子

   - 每次移动一块碟子,小的只能叠在大的上面

   - 把所有碟子从A杆全部移到C杆上

   请输出碟子的移动顺序。
   
   ```java
   public static void doTowers(int topN, char from, char inter, char to) {
       if (topN == 1){
           System.out.println("Disk 1 from " + from + " to " + to);
       }else {
           doTowers(topN - 1, from, to, inter);
           System.out.println("Disk " + topN + " from " + from + " to " + to);
           doTowers(topN - 1, inter, from, to);
       }
   }
   ```
   
   

## 快速排序算法

[查看快速排序算法](https://lee-0o0.github.io/doc-site/#/docs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95?id=_12-%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f)



## 作业

洛谷：

1. https://www.luogu.com.cn/problem/B2129
2. https://www.luogu.com.cn/problem/B2127
3. https://www.luogu.com.cn/problem/B2128
4. https://www.luogu.com.cn/problem/B2104



## 参考资料

[1] 汉诺塔：https://zh.wikipedia.org/wiki/%E6%B1%89%E8%AF%BA%E5%A1%94