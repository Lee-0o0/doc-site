# Java基础— —内部类

本文主要介绍内部类的知识。

[toc]

## 一、内部类介绍与分类

在Java中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。

广泛意义上的内部类一般来说包括四种：成员内部类、静态内部类、局部内部类、匿名内部类。



## 二、内部类的使用

### 2.1 成员内部类

成员内部类是最简单的内部类，定义在外部类中，就像外部类的成员变量一样。定义形式如下：

```java
// 外部类
class Outter{
    
    // 外部类属性和方法
    
    // 内部类
    [访问修饰符] class Inner{
        // 内部类属性和方法
    }
}
```

- 内部类中不能定义静态成员变量和静态方法；

- 内部类可以拥有四种访问权限：`private`、`protected`、`public`及包访问权限。

  如果成员内部类`Inner`用`private`修饰，则只能在外部类的内部访问；

  如果用`public`修饰，则任何地方都能访问；

  如果用`protected`修饰，则只能在同一个包下或者继承外部类的情况下访问；

  如果是默认访问权限（包访问权限），则只能在同一个包下访问。

  这一点和外部类有一点不一样，外部类只能被`public`和`包访问`两种权限修饰。由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰。

- 成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。

  当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：

  ```java
  外部类.this.成员变量
  外部类.this.成员方法
  ```

- 虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问。创建成员内部类的一般形式为：

  ```java
  外部类 xxx = new 外部类();
  外部类类名.内部类类名 yyy = xxx.new 内部类();
  ```



### 2.2 静态内部类

静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字`static`。它**不能使用外部类的非static成员变量或者方法**，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非`static`成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。

静态内部类定义形式如下：

```java
// 外部类
class Outter{
    
    // 外部类属性和方法
    
    // 内部类
    [访问修饰符] static class Inner{
        // 静态内部类属性和方法
    }
}
```

创建静态内部类对象的一般形式为： 

```java
外部类类名.内部类类名 xxx = new 外部类类名.内部类类名()
```



### 2.3 局部内部类

局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。

注意，局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。

例如：

```java
class Man{
    public Man(){
         
    }
     
    public People getWoman(){
        class Woman extends People{   //局部内部类
            int age =0;
        }
        return new Woman();
    }
}
```



### 2.4 匿名内部类

匿名内部类也就是没有名字的内部类，正因为没有名字，所以匿名内部类只能使用一次，它通常用来简化代码编写。使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口。

例如：

```java
public class Demo {
    public static void main(String[] args) {
        Thread t = new Thread() {
            public void run() {
                for (int i = 1; i <= 5; i++) {
                    System.out.print(i + " ");
                }
            }
        };
        t.start();
    }
}
```

匿名内部类继承了父类`Thread`并重写了方法`run()`。`Thread`本身并不是抽象类，因为覆盖了`run()`方法，`run()`的表现形式和父类不同，只有子类可以实现这个特性，所以`new`出来的并不是`Thread`类，而是`Thread`类的匿名子类，即匿名内部类。如果不重写`run`方法，那么`new`出来的就是`Thread`类本身，就不存在匿名内部类了。





## 三、参考资料

[1] 内部类介绍：https://www.cnblogs.com/dolphin0520/p/3811445.html

[2] 匿名内部类例子：https://www.cnblogs.com/nerxious/archive/2013/01/25/2876489.html