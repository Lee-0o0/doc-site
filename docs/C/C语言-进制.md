# C语言— —进制

本文主要介绍进制、进制转换、原码反码补码的知识。

## 1. 进制

本章主要介绍什么是进制。现有数字 6179，从右到左分别为个位、十位、百位、千位，这是我们小学的知识了（所以不用害怕知识有多难，我们小学就接触了）。

![image-20210815204904774](https://cdn.jsdelivr.net/gh/Lee-0o0/image-store/PicGo/2021-10-05/650360c805b9b50906ee060433cc7d56--95d1--image-20210815204904774.png)

6179 就是一个十进制数，而我们在平时的生活中接触到的也是十进制数。现在我们来说说十进制数的特点：

- 从右到左，分别为个位、十位、百位、千位、万位......；
- 每一位上的数字可以为0-9之间的任意一个数字；
- 逢十进一；

在编程世界中，最基础的是二进制，那么什么是二进制呢？类比十进制，二进制有如下特点：

- 我们也可以将二进制的数从右到左分为每一位；
- 每一位上的数字要么是0，要么是1；
- 逢二进一；

例如，二进制下的数字 10010。

除了二进制，我们还常用八进制、十六进制。再次总结一下进制的知识：

-  对于n进制，每一位上的数字可以为`[0,n-1]`；
-  对于n进制，低位的数字逢n进一。

以十六进制为例，每一位上的数字可以为`[0，15]`，例如：

![image-20210815210125326](https://cdn.jsdelivr.net/gh/Lee-0o0/image-store/PicGo/2021-10-05/b38b3be4d8c2134ccd626cfdbe4d0b67--3340--image-20210815210125326.png)

可是，这种表示方法有歧义，我们用一个方框表示一位，可是在实际使用中是没有这个方框的，那么就会显示如下图，可以有两种以上的理解：

![image-20210815210345988](https://cdn.jsdelivr.net/gh/Lee-0o0/image-store/PicGo/2021-10-05/61097c3090a42a22e7f1e944c357fc59--426b--image-20210815210345988.png)

这就造成了歧义，原因是[10,15]的数字我们用了两位来表示，为了消除歧义，我们用A-F分别表示10-15：

![image-20210815210058614](https://cdn.jsdelivr.net/gh/Lee-0o0/image-store/PicGo/2021-10-05/4ae76e14b253f5f278b53b7b4598a2c5--3ad3--image-20210815210058614.png)

所以十六进制的每一位上的数字可以为[0,15]，但是为了消除歧义，10-15分别用A-F来表示。



## 2. 进制转换

本节主要介绍同一个数不同进制之间的转换。我们以角标$X_{(n)}$表示X是n进制数。

### 2.1 十进制转换为其它进制

我们分别以二进制、八进制为例，介绍十进制整数是如何转换为其它进制的。

其实十进制转换为其他进制所采用的方法是一样的，假设十进制转换为n进制，那么该方法可以称为“除n取余，逆序排列”。更准确地描述为，现有一个十进制数x，将其转换为n进制数，则转换方法为：

- 首先计算 x ÷ n = p ... q，得到商为p，余数为 q；
- 再根据上一步得到的商 p 继续同样的步骤 p ÷ n = $p_1 ... q_1$，得到商为$p_1$，余数为$q_1$；
- 直到商为0；
- 最后将余数逆序从左至右排列 $p_np_{n-1}...p_1p$，则 $p_np_{n-1}...p_1p$就是转换后的n进制数；

以十进制数$100_{(10)}$转换为二进制数为例：
$$
第一步： 100 \div 2 = 50 ... 0 \\
第二步： 50 \div 2 = 25 ... 0 \\
第三步： 25 \div 2 = 12 ... 1 \\
第四步: 12 \div 2 = 6 ... 0 \\
第五步： 6 \div 2 = 3 ... 0 \\
第六步： 3 \div 2 = 1 ... 1 \\
第七步： 1 \div 2 = 0 ... 1 \\
$$
最后将余数逆序排列，得到$100_{(10)}$的二进制形式为$1100100_{(2)}$。

在实际的转换中，我们可以按照如下的写法进行简化：

<img src="https://cdn.jsdelivr.net/gh/Lee-0o0/image-store/PicGo/2021-10-05/c61dcafcdc93db4728bccd14fcd9be5a--68b9--C61DCAFCDC93DB4728BCCD14FCD9BE5A.png" alt="img" style="zoom: 33%;" />

同理，十进制数$100_{(10)}$转换为八进制数的步骤如下：

<img src="https://cdn.jsdelivr.net/gh/Lee-0o0/image-store/PicGo/2021-10-05/f47673e29a5e1471a7cc19ba0f0df9f7--70ca--F47673E29A5E1471A7CC19BA0F0DF9F7.png" alt="img" style="zoom:33%;" />



即十进制数$100_{(10)}$转换为八进制数为$144_{(8)}$。



十进制小数转换为n进制的小数，所采用的方法是“乘n取整，顺序排列”。我们以二进制和八进制为例，介绍$0.625_{(10)}$转换为其他进制小数：

```txt
0.625 x 2 = 1.250  取整    1
0.250 x 2 = 0.5    取整    0
0.5 x 2 = 1.0      取整    1
```

当最后的小数为0或达到指定精度时，结束转换。所以$0.625_{(10)}$转换为二进制小数为$0.101_{(2)}$。

同理，$0.625_{(10)}$转换为八进制小数结果如下：

```txt
0.625 x 8 = 5   取整   5
```

$0.625_{(10)}$转换为八进制小数结果为$0.5_{(8)}$。



### 2.2 其它进制转换为十进制

现有一个n进制数$p_{x-1}...p_1p_0$，共有x位，则将其转换位十进制数的公式为：
$$
\begin{aligned}
{p_{x-1}···p_1p_0 . p_{-1}p_{-2}···p_{-n}}_{(n)} &= p_{x-1} \times n^{x-1} + ··· + p_1\times n^1 + p_0\times n^0 + p_{-1} \times n^{-1} + p_{-2} \times n^{-2} + ··· +p_{-n}\times n^{-n} \\ &= \sum_{k = -n}^{x-1}p_k\times n^k
\end{aligned}
$$


例如，现有二进制数$11101100_{(2)}$，转换为十进制数如下：
$$
\begin{aligned}
11101100_{(2)} &= 1\times 2^7 + 1 \times 2^6 + 1 \times2^5 + 0\times2^4 + 1\times2^3 +1\times2^2 + 0\times2^1 + 0\times2^0 \\&= 128 + 64 + 32+0+8 + 4+0+0 \\ &=236
\end{aligned}
$$

现有二进制数$110.1011_{(2)}$，转换为是十进制数如下：
$$
\begin{aligned}
110.1011_{(2)} &= 1\times2^2 + 1 \times 2^1 +0\times 2^0 + 1\times2^{-1} + 0\times2^{-2} + 1\times2^{-3}+1\times2^{-4} \\&= 4 + 2 + 0 + 0.5 + 0 + 0.125 + 0.0625 \\&=6.6875
\end{aligned}
$$


### 2.3 二进制、八进制、十六进制之间的转换

由于二进制、八进制和十六进制之间存在特殊的对应关系，所以二进制和八进制、十六进制之间的互相转换存在简便方法。

首先，我们先确定三位二进制数的对应关系：

| 000  | 001  | 010  | 011  | 100  | 101  | 110  | 111  |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    |

三位二进制数所对应的十进制数为0—7，这就是八进制中的八个数字。

二进制数转换为八进制数的方法如下：对于二进制数，从右到左，以三位二进制数为一组，若最后一组不足三位，则高位补零。然后依次将每组的二进制数按照对应关系转换为八进制数，得到的结果就是八进制数。

例如，现有二进制数$11001101010010_{(2)}$，将其转换为八进制数的步骤如下：

首先从右到左以三位二进制数为一组：
$$
11 \quad 001 \quad 101 \quad 010 \quad 010
$$
可以看到最左边的一组（最后一组）不足三位，则最高位补零：
$$
011 \quad 001 \quad 101 \quad 010 \quad 010
$$
然后按照对应关系，将每组转换为八进制数：
$$
011 \quad 001 \quad 101 \quad 010 \quad 010 = 3\quad 1\quad 5 \quad 2\quad 2 = 31522_{(8)}
$$
即二进制数$11001101010010_{(2)}$转换为八进制数为$31522_{(8)}$。

同理，二进制数转换为十六进制数，就是四位二进制数与十六进制数的对应关系：

| 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| 1000 | 1001 | 1010 | 1011 | 1100 | 1101 | 1110 | 1111 |
| 8    | 9    | A    | B    | C    | D    | E    | F    |

转换方法类似：对于二进制数，从右到左，以四位二进制数为一组，若最后一组不足四位，则高位补零。然后依次将每组的二进制数按照对应关系转换为十六进制数，得到的结果就是十六进制数。

例如，现有二进制数$11101111010010_{(2)}$，将其转换为十六进制数的步骤如下：

首先从右到左以四位二进制数为一组：
$$
11  \quad 1011 \quad 1101 \quad 0010
$$
可以看到最左边的一组（最后一组）不足四位，则最高位补零：
$$
0011  \quad 1011 \quad 1101 \quad 0010
$$
然后按照对应关系，将每组转换为十六进制数：
$$
0011  \quad 1011 \quad 1101 \quad 0010 = 3 \quad B \quad D \quad2 = 3BD2_{(16)}
$$
即二进制数$11101111010010_{(2)}$转换为十六进制数为$3BD2_{(16)}$。



## 3. 二进制中的存储单位

对于二进制中的一位，我们称之为比特位(bit)，即一位=1bit，在此基础上，有如下单位：

- 1字节=8位，即1byte=8bit，缩写为1B = 8b
- 1千字节 = 1024字节，即$1KB = 2^{10}B$
- 1兆字节 = 1024千字节，即$1 MB = 2^{20}B $
- 1吉字节 = 1024兆字节，即$1GB = 2^{30}B$
- 1太字节 = 1024吉字节，即$1 TB = 1024GB = 2^{40}B$

还有更高的单位，但是平时也涉及不到，因此此处只罗列常见的。



## 4. 原码、反码、补码

### 4.1 原码、反码和补码

本文介绍**整数**的几种编码方式。

**原码：**原码将数字的二进制分为两部分，符号位和数字的绝对值二进制表示；对于正数来说，符号位为0；对于负数来说，符号位为1。例如，用8位二进制位来存储整数，10和-10的原码表示如下：

```txt
10:  0000 1010
-10: 1000 1010
```

**反码**：对于正数来说，反码就是原码；对于负数来说，反码就是在原码的基础上，符号位不变，其余位反转。例如，10和-10的反码如下：

```txt
10:  0000 1010
-10: 1111 0101
```

**补码**：对于正数来说，补码就是原码；对于负数来说，补码就是在反码的基础上，加1。例如，10和-10的补码如下：

```txt
10:  0000 1010
-10: 1111 0110
```

**在C语言中，存储整数都是按照补码的形式来存储的。**

从十进制整数到二进制补码的转换我们已经了解了，那么如何从补码快速得到十进制整数呢？
$$
对于一个n位的二进制补码\{x_{n-1}, x_{n-2} ... x_1, x_0\}来说，将其转换为对应的十进制整数方法如下：\\
\{x_{n-1}, x_{n-2} ... x_1, x_0\} = -x_{n-1}*2^{n-1} + \sum_{k = 0}^{n-2}x^{k}2^k
$$


### 4.2 为什么用补码存储整数？

首先我们来看原码的不足之处：

- 原码计算涉及负数的减法存在问题。例如，计算 1 - 1，1 - 1 也可以看成 1 + （ -1 ） ，则转换为原码（以8位二进制数来存储整数）为：

  ```txt
  1 + (-1) = 00000001 + 10000001 = 10000010 = -2
  ```

  这样的计算结果显然是不对的。

- 在原码表示中，0有两种表示方式。

  ```txt
  00000000: +0
  10000000: -0
  ```

  在原码表示中，0分为了+0和-0，这显然是不符合我们的习惯的，0是不分正负的。

再来看看反码有何不足之处：

- 反码对于两个负数的加法计算存在问题。例如，计算 - 1 + (-1)：

  ```txt
  -1 + (-1) = 11111110 + 11111110 = 1 00000000 = 00000000 = 0
  ```

  由于只用8位二进制位来存储数据，所以最高位的1省去。最后结果为0，结果显然不对。

- 在反码表示中，0仍然有两种表示方式。

  ```txt
  00000000: +0
  11111111: -0
  ```

为了解决原码和反码存在的问题，提出了补码。



## 参考资料

[1] 进制：https://zh.wikipedia.org/wiki/%E8%BF%9B%E4%BD%8D%E5%88%B6